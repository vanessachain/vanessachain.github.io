<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>python基本语法之函数 | 法师摘小瓜笔记堂</title>
<link rel="shortcut icon" href="https://vanessachain.github.io/favicon.ico?v=1654504031504">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://vanessachain.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="python基本语法之函数 | 法师摘小瓜笔记堂 - Atom Feed" href="https://vanessachain.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
小摘花python课堂更新啦！

定义和调用函数
def greet(name): #函数名
    print(name+'早上好') #函数体 
    return #返回值

greet('Lily') #调用函数，输入函数名pi..." />
    <meta name="keywords" content="python" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://vanessachain.github.io">
  <img class="avatar" src="https://vanessachain.github.io/images/avatar.png?v=1654504031504" alt="">
  </a>
  <h1 class="site-title">
    法师摘小瓜笔记堂
  </h1>
  <p class="site-description">
    在民法慈母般的眼神里，每个人就是整个国家。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              python基本语法之函数
            </h2>
            <div class="post-info">
              <span>
                2021-08-16
              </span>
              <span>
                4 min read
              </span>
              
                <a href="https://vanessachain.github.io/tag/jHttudT3y/" class="post-tag">
                  # python
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <blockquote>
<p>小摘花python课堂更新啦！</p>
</blockquote>
<h2 id="定义和调用函数">定义和调用函数</h2>
<pre><code>def greet(name): #函数名
    print(name+'早上好') #函数体 
    return #返回值

greet('Lily') #调用函数，输入函数名pika()并输入参数'Lily'
&gt;&gt;Lily早上好
</code></pre>
<h2 id="位置参数">位置参数</h2>
<pre><code>def  menu(appetizer,course):
    print('一份开胃菜：'+appetizer)
    print('一份主食：'+course)

menu('话梅花生','牛肉拉面')
&gt;&gt;一份话梅花生
&gt;&gt;一份牛肉拉面
</code></pre>
<h2 id="默认参数">默认参数</h2>
<pre><code>def  menu(appetizer,course,dessert='绿豆沙'):
    print('一份开胃菜：'+appetizer)
    print('一份主食：'+course)
    print('一份甜品：'+dessert)
    
menu('话梅花生','牛肉拉面') 
#因为已经默认将'绿豆沙'传递给dessert，调用时无须再传递。
&gt;&gt;一份开胃菜话梅花生
&gt;&gt;一份主食牛肉拉面
&gt;&gt;一份甜品绿豆沙
</code></pre>
<h2 id="不定长参数">不定长参数</h2>
<pre><code>def menu(appetizer,course,*barbeque,dessert='绿豆沙'):
    print('一份开胃菜：'+appetizer)
    print('一份主菜：'+course)
    print('一份甜品：'+dessert) 
    #这时候默认参数也需要放在不定长参数的后面，即dessert=’绿豆沙'要放在*barbeque后面，否则传递的值会对应不上。
    for i in barbeque:
        print('一份烤串：'+i)
    
menu('话梅花生','牛肉拉面','烤鸡翅','烤茄子','烤玉米')
&gt;&gt;一份开胃菜话梅花生
&gt;&gt;一份主菜牛肉拉面
&gt;&gt;一份甜品绿豆沙
&gt;&gt;一份烤串烤鸡翅
&gt;&gt;一份烤串考茄子
&gt;&gt;一份烤串烤玉米
</code></pre>
<h2 id="return语法">return语法</h2>
<pre><code>def age_question(age):
    if age &lt; 12:
        return '哈，是祖国的花朵啊'
    elif age &lt; 25:
        return '哇，是小鲜肉呢'
    else:
        return '嗯，人生才刚刚开始'

print(age_question(30))
&gt;&gt;嗯，人生才刚刚开始
</code></pre>
<blockquote>
<p><strong>return语句的作用</strong>：当多个函数之间相互配合时，我们并不需要第一时间就将结果打印出来，而是需要将某个返回值先放着，等到需要的时候再做进一步的处理。return语句可以保留返回值。</p>
</blockquote>
<pre><code>def face(name):
    return name + '的脸蛋'
def body(name):
    return name + '的身材'

print('我的梦中情人：'+face('李若彤') +' + ' + body('林志玲'))
&gt;&gt;我的梦中情人：李若彤的脸蛋+李志玲的身材
</code></pre>
<h2 id="main主函数">main（）主函数</h2>
<pre><code>def face(name):
    return name + '的脸蛋'
def body(name):
    return name + '的身材'
def main(dream_face,dream_body):
    return '我的梦中情人：' + face(dream_face) + ' + ' + body(dream_body)

print(main('李若彤','林志玲'))
print(main('新垣结衣','长泽雅美'))
</code></pre>
<h2 id="一次性返回两个值一次接受多个返回值的数据类型就是元组">一次性返回两个值：一次接受多个返回值的数据类型就是元组。</h2>
<pre><code>def lover(name1,name2):
    face = name1 + '的脸蛋'
    body = name2 + '的身材'
    return face,body

a=lover('李若彤','林志玲')  #此时返回的是元组是('李若彤的脸蛋','林志玲的身材')
print('我的梦中情人：'+a[0]+' + '+a[1])
</code></pre>
<h2 id="没有return语句的函数会默认返回none值">没有return语句的函数会默认返回none值</h2>
<h2 id="变量作用域">变量作用域</h2>
<blockquote>
<p>第一点：在一个函数内定义的变量仅能在函数内部使用（局部作用域），它们被称作[局部变量]。<br>
第二点：在所有函数之外赋值的变量，可以在程序的任何位置使用（全局作用域），被称作[全局变量]。<br>
当变量处于被定义的函数内时，就是局部变量，只能在这个函数内被访问；当变量处于被定义的函数外时，就是全局变量，可以在程序中的任何位置被访问。</p>
</blockquote>
<pre><code>x=99
def num():
    x=88
    print(x)

num() 
*打印局部变量x*
print(x) 
*打印全局变量x*


def egg():    
    quantity = 108
egg()
print(quantity)   
*会报错，不能在函数外部（全局作用域）使用函数内的局部变量*

quantity = 108
def egg():
    print(quantity)
egg()
*函数内的局部作用域，可以访问全局变量*

def egg():    
    global quantity
    quantity = 108
egg()
print(quantity)
*global语句可以将局部变量声明为全局变量*
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0">定义和调用函数</a></li>
<li><a href="#%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0">位置参数</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">默认参数</a></li>
<li><a href="#%E4%B8%8D%E5%AE%9A%E9%95%BF%E5%8F%82%E6%95%B0">不定长参数</a></li>
<li><a href="#return%E8%AF%AD%E6%B3%95">return语法</a></li>
<li><a href="#main%E4%B8%BB%E5%87%BD%E6%95%B0">main（）主函数</a></li>
<li><a href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E8%BF%94%E5%9B%9E%E4%B8%A4%E4%B8%AA%E5%80%BC%E4%B8%80%E6%AC%A1%E6%8E%A5%E5%8F%97%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B0%B1%E6%98%AF%E5%85%83%E7%BB%84">一次性返回两个值：一次接受多个返回值的数据类型就是元组。</a></li>
<li><a href="#%E6%B2%A1%E6%9C%89return%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%9A%E9%BB%98%E8%AE%A4%E8%BF%94%E5%9B%9Enone%E5%80%BC">没有return语句的函数会默认返回none值</a></li>
<li><a href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">变量作用域</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://vanessachain.github.io/post/kevin-ying-yu-ting-li-kou-yu-fa-yin-ti-gao-mi-jue/">
              <h3 class="post-title">
                kevin英语听力口语发音提高秘诀
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://vanessachain.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
